<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>テレビぶん投げゲーム</title>
<style>
body{margin:0;overflow:hidden;background:#87ceeb}
canvas{display:block}
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.22.0/dist/cannon-es.js"></script>
<script>
let scene=new THREE.Scene()
scene.background=new THREE.Color(0x87ceeb)
let camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100)
camera.position.set(5,5,8)
camera.lookAt(0,1,0)
let renderer=new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
document.body.appendChild(renderer.domElement)
let controls=new THREE.OrbitControls(camera,renderer.domElement)
controls.enableDamping=true

let light=new THREE.DirectionalLight(0xffffff,1)
light.position.set(10,10,10)
scene.add(light)
scene.add(new THREE.AmbientLight(0x888888))

let world=new CANNON.World()
world.gravity.set(0,-9.82,0)

function createRoom(){
    let floorShape=new CANNON.Box(new CANNON.Vec3(5,0.1,5))
    let floorBody=new CANNON.Body({mass:0,shape:floorShape})
    floorBody.position.set(0,0,0)
    world.addBody(floorBody)
    let floorMesh=new THREE.Mesh(new THREE.BoxGeometry(10,0.2,10),new THREE.MeshStandardMaterial({color:0x808080}))
    floorMesh.position.copy(floorBody.position)
    scene.add(floorMesh)

    let wallGeo=new THREE.BoxGeometry(10,3,0.2)
    let wallPositions=[[-5,1.5,0],[5,1.5,0],[0,1.5,-5],[0,1.5,5]]
    wallPositions.forEach((p,i)=>{
        let wallBody=new CANNON.Body({mass:0,shape:new CANNON.Box(new CANNON.Vec3(5,1.5,0.1))})
        wallBody.position.set(p[0],p[1],p[2])
        world.addBody(wallBody)
        let wallMesh=new THREE.Mesh(wallGeo,new THREE.MeshStandardMaterial({color:0xffffff}))
        if(i<2) wallMesh.rotation.y=Math.PI/2
        wallMesh.position.copy(wallBody.position)
        scene.add(wallMesh)
    })
}
createRoom()

function createTV(x,z){
    let group=new THREE.Group()
    let bodyMat=new THREE.MeshStandardMaterial({color:0x333333,metalness:0.5,roughness:0.5,flatShading:true})
    let bodyMesh=new THREE.Mesh(new THREE.BoxGeometry(1.5,1,0.5),bodyMat)
    group.add(bodyMesh)

    let screenMesh=new THREE.Mesh(new THREE.PlaneGeometry(1.2,0.7),new THREE.MeshStandardMaterial({color:0x000000}))
    screenMesh.position.z=0.26
    group.add(screenMesh)

    let antMat=new THREE.MeshStandardMaterial({color:0xaaaaaa})
    let ant1=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,1),antMat)
    let ant2=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,1),antMat)
    ant1.position.set(-0.3,0.5,0)
    ant2.position.set(0.3,0.5,0)
    ant1.rotation.z=Math.PI/4
    ant2.rotation.z=-Math.PI/4
    group.add(ant1,ant2)

    let shape=new CANNON.Box(new CANNON.Vec3(0.75,0.5,0.25))
    let body=new CANNON.Body({mass:2,shape:shape})
    body.position.set(x,1, z)
    world.addBody(body)

    group.userData.body=body
    scene.add(group)
    return group
}

let tvs=[createTV(0,0)]

window.addEventListener('pointerdown',()=>{
    tvs.forEach(tv=>{
        let b=tv.userData.body
        b.velocity.set((Math.random()-0.5)*8,5+(Math.random()*5),(Math.random()-0.5)*8)
        b.angularVelocity.set((Math.random()-0.5)*5,(Math.random()-0.5)*5,(Math.random()-0.5)*5)
    })
})

function animate(){
    requestAnimationFrame(animate)
    world.step(1/60)
    tvs.forEach(tv=>{
        let b=tv.userData.body
        tv.position.copy(b.position)
        tv.quaternion.copy(b.quaternion)
    })
    controls.update()
    renderer.render(scene,camera)
}
animate()
</script>
</body>
</html>
