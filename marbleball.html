<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Marble Ball 2D</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #ui{position:fixed;left:12px;top:12px;display:flex;flex-wrap:wrap;gap:6px;z-index:20}
  #ui button{background:#222;color:#ddd;border:1px solid #444;border-radius:8px;padding:6px 10px;cursor:pointer}
  #ui .group{display:flex;gap:6px}
  #msg{position:fixed;left:12px;bottom:12px;color:#9fd;background:rgba(0,0,0,.4);padding:6px 10px;border:1px solid #244;border-radius:8px;font-size:12px;white-space:pre-line;max-width:min(680px,80vw);z-index:20}
  #palette{position:fixed;left:12px;top:80px;display:flex;flex-direction:column;gap:6px;background:#1a1a1a;padding:6px;border-radius:8px;z-index:20}
  #palette button{background:#333;color:#ddd;border:1px solid #555;border-radius:6px;padding:4px;cursor:grab;font-size:12px}
  #stage{position:fixed;inset:0;z-index:0}
  #world,#overlay{position:absolute;left:0;top:0;width:100vw;height:100vh;display:block}
  #world{background:#111}
  #overlay{pointer-events:none;}
</style>
</head>
<body>
<div id="ui">
  <div class="group">
    <button id="playBtn">プレイ開始</button>
    <button id="stopBtn">停止</button>
    <button id="editBtn">編集</button>
    <button id="setStartBtn">スタート位置</button>
    <button id="setGoalBtn">ゴール位置</button>
  </div>
  <div class="group">
    <button id="addBallBtn">ボール追加</button>
    <button id="clearBallsBtn">ボール消去</button>
  </div>
  <div class="group">
    <button id="undoBtn" disabled>戻す</button>
    <button id="clearCourseBtn">コース全消去</button>
    <button id="eraserBtn">消しゴム</button>
  </div>
  <div class="group">
    <button id="saveBtn">コース保存</button>
    <button id="loadBtn">コース読込</button>
  </div>
</div>
<div id="palette">
  <button draggable="true" data-shape="rect">四角</button>
  <button draggable="true" data-shape="tri">三角</button>
  <button draggable="true" data-shape="circle">丸</button>
  <button data-shape="line" id="lineBtn">線（ドラッグで地形）</button>
</div>
<pre id="msg"></pre>

<div id="stage">
  <canvas id="world"></canvas>
  <canvas id="overlay"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
(() => {
  const {Engine, Render, Runner, World, Bodies, Body, Events} = Matter;
  const engine = Engine.create();
  engine.gravity.y = 1.2;

  const worldCanvas = document.getElementById('world');
  const overlayCanvas = document.getElementById('overlay');
  const octx = overlayCanvas.getContext('2d');

  const render = Render.create({
    canvas: worldCanvas,
    engine,
    options: { wireframes: false, background: '#111', width: window.innerWidth, height: window.innerHeight }
  });
  Render.run(render);
  const runner = Runner.create();
  Runner.run(runner, engine);

  function resize(){
    worldCanvas.width = overlayCanvas.width = window.innerWidth;
    worldCanvas.height = overlayCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize); resize();

  const balls=[]; const msg=document.getElementById('msg');
  const startMarker = Bodies.circle(180, 180, 14, {isStatic:true, render:{fillStyle:'#1e90ff'}});
  const goalRadius=22;
  const goalSensor=Bodies.circle(520,300,goalRadius,{isStatic:true,isSensor:true,render:{fillStyle:'transparent',strokeStyle:'#0f8',lineWidth:3}});
  World.add(engine.world,[startMarker,goalSensor]);

  let mode='edit';
  const playBtn=document.getElementById('playBtn');
  const stopBtn=document.getElementById('stopBtn');
  const editBtn=document.getElementById('editBtn');
  const setStartBtn=document.getElementById('setStartBtn');
  const setGoalBtn=document.getElementById('setGoalBtn');
  const addBallBtn=document.getElementById('addBallBtn');
  const clearBallsBtn=document.getElementById('clearBallsBtn');
  const undoBtn=document.getElementById('undoBtn');
  const clearCourseBtn=document.getElementById('clearCourseBtn');
  const lineBtn=document.getElementById('lineBtn');
  const saveBtn=document.getElementById('saveBtn');
  const loadBtn=document.getElementById('loadBtn');
  const eraserBtn=document.getElementById('eraserBtn');

  function setMode(m){ mode=m; flash(`モード: ${m}`); }
  setMode('edit');

  playBtn.onclick=()=>{ setMode('play'); spawnBall(); };
  stopBtn.onclick=()=>{ setMode('edit'); clearBalls(); };
  editBtn.onclick=()=> setMode('edit');
  setStartBtn.onclick=()=> setMode('setStart');
  setGoalBtn.onclick=()=> setMode('setGoal');
  addBallBtn.onclick=()=> spawnBall();
  clearBallsBtn.onclick=()=> clearBalls();
  clearCourseBtn.onclick=()=> clearCourse();
  eraserBtn.onclick=()=> setMode('eraser');

  function randCol(){return `hsl(${(Math.random()*360)|0} 80% 60%)`;}
  function spawnBall(){const {x,y}=startMarker.position;const ball=Bodies.circle(x,y,12,{restitution:0.3,frictionAir:0.005,render:{fillStyle:randCol()}});balls.push(ball);World.add(engine.world,ball);}  
  function clearBalls(){balls.splice(0).forEach(b=>World.remove(engine.world,b));}

  const placedWalls=[];
  function addWall(x,y,w,h,angle=0){const wall=Bodies.rectangle(x,y,w,h,{isStatic:true,angle,render:{fillStyle:'#e6e6e6'}});World.add(engine.world,wall);placedWalls.push({type:'rect',x,y,w,h,angle});}
  function addCircle(x,y,r){const c=Bodies.circle(x,y,r,{isStatic:true,render:{fillStyle:'#e6e6e6'}});World.add(engine.world,c);placedWalls.push({type:'circle',x,y,r});}
  function addTriangle(x,y){const s=30;const t=Bodies.polygon(x,y,3,s,{isStatic:true,render:{fillStyle:'#e6e6e6'}});World.add(engine.world,t);placedWalls.push({type:'tri',x,y,s});}

  undoBtn.onclick=()=>{ placedWalls.pop(); rebuildCourse(); };
  function clearCourse(){ placedWalls.splice(0); rebuildCourse(); }

  function rebuildCourse(){
    const ballsCopy=[...balls];
    World.clear(engine.world,false);
    World.add(engine.world,[startMarker,goalSensor]);
    placedWalls.forEach(o=>{
      if(o.type==='rect') addWall(o.x,o.y,o.w,o.h,o.angle);
      if(o.type==='circle') addCircle(o.x,o.y,o.r);
      if(o.type==='tri') addTriangle(o.x,o.y);
    });
    ballsCopy.forEach(b=>World.add(engine.world,b));
  }

  const palette=document.getElementById('palette');
  palette.querySelectorAll('[draggable=true]').forEach(btn=>{
    btn.addEventListener('dragstart',ev=>{ev.dataTransfer.setData('shape',btn.dataset.shape);});
  });
  worldCanvas.addEventListener('dragover',ev=>ev.preventDefault());
  worldCanvas.addEventListener('drop',ev=>{
    ev.preventDefault();
    const shape=ev.dataTransfer.getData('shape');
    const rect=worldCanvas.getBoundingClientRect();
    const x=ev.clientX-rect.left, y=ev.clientY-rect.top;
    if(shape==='rect') addWall(x,y,40,40);
    if(shape==='circle') addCircle(x,y,20);
    if(shape==='tri') addTriangle(x,y);
  });
  lineBtn.onclick=()=>{ currentShape = (currentShape==='line'? null : 'line'); setMode('edit'); };

  let drawingLine=false,sx=0,sy=0,ex=0,ey=0;
  let draggingStart=false, draggingGoal=false;

  worldCanvas.addEventListener('mousedown',ev=>{
    const {x,y}=getMouse(ev);
    if(mode==='edit' && currentShape==='line'){
      drawingLine=true; sx=x; sy=y; ex=x; ey=y;
    } else if(mode==='setStart'){
      draggingStart=true;
    } else if(mode==='setGoal'){
      draggingGoal=true;
    } else if(mode==='eraser'){
      for(let i=placedWalls.length-1;i>=0;i--){
        const o=placedWalls[i];
        if(o.type==='rect' && Math.abs(o.x-x)<40 && Math.abs(o.y-y)<40){ placedWalls.splice(i,1); break; }
        if(o.type==='circle' && Math.hypot(o.x-x,o.y-y)<o.r){ placedWalls.splice(i,1); break; }
        if(o.type==='tri' && Math.abs(o.x-x)<30 && Math.abs(o.y-y)<30){ placedWalls.splice(i,1); break; }
      }
      rebuildCourse();
    }
  });
  window.addEventListener('mousemove',ev=>{
    const {x,y}=getMouse(ev);
    if(drawingLine){ ex=x; ey=y; }
    if(draggingStart){ Body.setPosition(startMarker,{x,y}); }
    if(draggingGoal){ Body.setPosition(goalSensor,{x,y}); }
  });
  window.addEventListener('mouseup',()=>{
    if(drawingLine){ drawingLine=false; const len=Math.hypot(ex-sx,ey-sy); if(len>6){ addWall((sx+ex)/2,(sy+ey)/2,len,8,Math.atan2(ey-sy,ex-sx)); }}
    draggingStart=false; draggingGoal=false;
  });

  function getMouse(ev){ const r=worldCanvas.getBoundingClientRect(); return {x:ev.clientX-r.left, y:ev.clientY-r.top}; }

  function drawOverlay(){
    octx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    if(drawingLine && mode==='edit' && currentShape==='line'){
      octx.beginPath(); octx.moveTo(sx,sy); octx.lineTo(ex,ey);
      octx.lineWidth = 3; octx.strokeStyle = '#55aaff'; octx.stroke();
    }
    requestAnimationFrame(drawOverlay);
  }
  requestAnimationFrame(drawOverlay);

  let currentShape=null;

  saveBtn.onclick=()=>{
    const data={walls:placedWalls,start:startMarker.position,goal:goalSensor.position};
    const blob=new Blob([JSON.stringify(data)],{type:'text/plain'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='course.txt';
    a.click();
  };

  loadBtn.onclick=()=>{
    const input=document.createElement('input');
    input.type='file';
    input.accept='text/plain';
    input.onchange=()=>{
      const file=input.files[0];
      const reader=new FileReader();
      reader.onload=()=>{
        const data=JSON.parse(reader.result);
        placedWalls.splice(0,placedWalls.length,...data.walls);
        Body.setPosition(startMarker,data.start);
        Body.setPosition(goalSensor,data.goal);
        rebuildCourse();
      };
      reader.readAsText(file);
    };
    input.click();
  };

  function flash(t){ msg.textContent=t; clearTimeout(flash._t); flash._t=setTimeout(()=>msg.textContent='',2500); }
})();
</script>
</body>
</html>
