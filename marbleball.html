<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Marble Ball 2D</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #ui{position:fixed;left:12px;top:12px;display:flex;flex-wrap:wrap;gap:6px;z-index:20}
  #ui button{background:#222;color:#ddd;border:1px solid #444;border-radius:8px;padding:6px 10px;cursor:pointer}
  #ui .group{display:flex;gap:6px}
  #msg{position:fixed;left:12px;bottom:12px;color:#9fd;background:rgba(0,0,0,.4);padding:6px 10px;border:1px solid #244;border-radius:8px;font-size:12px;white-space:pre-line;max-width:min(680px,80vw);z-index:20}
  #palette{position:fixed;left:12px;top:80px;display:flex;flex-direction:column;gap:6px;background:#1a1a1a;padding:6px;border-radius:8px;z-index:20}
  #palette button{background:#333;color:#ddd;border:1px solid #555;border-radius:6px;padding:4px;cursor:grab;font-size:12px}
  #stage{position:fixed;inset:0;z-index:0}
  #world,#overlay{position:absolute;left:0;top:0;width:100vw;height:100vh;display:block}
  #world{background:#111}
  #overlay{pointer-events:none;}
</style>
</head>
<body>
<div id="ui">
  <div class="group">
    <button id="playBtn">プレイ開始</button>
    <button id="stopBtn">停止</button>
    <button id="editBtn">編集</button>
    <button id="setStartBtn">スタート位置</button>
    <button id="setGoalBtn">ゴール位置</button>
  </div>
  <div class="group">
    <button id="addBallBtn">ボール追加</button>
    <button id="clearBallsBtn">ボール消去</button>
  </div>
  <div class="group">
    <button id="undoBtn" disabled>戻す</button>
    <button id="clearCourseBtn">コース全消去</button>
  </div>
  <div class="group">
    <button id="saveBtn">コース保存</button>
    <button id="loadBtn">コース読込</button>
  </div>
</div>
<div id="palette">
  <button draggable="true" data-shape="rect">四角</button>
  <button draggable="true" data-shape="tri">三角</button>
  <button draggable="true" data-shape="circle">丸</button>
  <button data-shape="line" id="lineBtn">線を書く</button>
  <button id="freehandBtn">フリーハンド地形</button>
  <button id="eraserBtn">消しゴム</button>
</div>
<pre id="msg"></pre>

<div id="stage">
  <canvas id="world"></canvas>
  <canvas id="overlay"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
(() => {
  const {Engine, Render, Runner, World, Bodies, Body} = Matter;
  const engine = Engine.create();
  engine.gravity.y = 1.2;

  const worldCanvas = document.getElementById('world');
  const overlayCanvas = document.getElementById('overlay');
  const octx = overlayCanvas.getContext('2d');

  const render = Render.create({
    canvas: worldCanvas,
    engine,
    options: { wireframes: false, background: '#111', width: window.innerWidth, height: window.innerHeight }
  });
  Render.run(render);
  const runner = Runner.create();
  Runner.run(runner, engine);

  function resize(){
    worldCanvas.width = overlayCanvas.width = window.innerWidth;
    worldCanvas.height = overlayCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize); resize();

  const balls=[]; const msg=document.getElementById('msg');
  const startMarker = Bodies.circle(180, 180, 14, {isStatic:true, render:{fillStyle:'#1e90ff'}});
  const goalRadius=22;
  const goalSensor=Bodies.circle(520,300,goalRadius,{isStatic:true,isSensor:true,render:{fillStyle:'transparent',strokeStyle:'#0f8',lineWidth:3}});
  World.add(engine.world,[startMarker,goalSensor]);

  let mode='edit';
  const playBtn=document.getElementById('playBtn');
  const stopBtn=document.getElementById('stopBtn');
  const editBtn=document.getElementById('editBtn');
  const setStartBtn=document.getElementById('setStartBtn');
  const setGoalBtn=document.getElementById('setGoalBtn');
  const addBallBtn=document.getElementById('addBallBtn');
  const clearBallsBtn=document.getElementById('clearBallsBtn');
  const undoBtn=document.getElementById('undoBtn');
  const clearCourseBtn=document.getElementById('clearCourseBtn');
  const lineBtn=document.getElementById('lineBtn');
  const saveBtn=document.getElementById('saveBtn');
  const loadBtn=document.getElementById('loadBtn');
  const eraserBtn=document.getElementById('eraserBtn');
  const freehandBtn=document.getElementById('freehandBtn');

  function setMode(m){ mode=m; flash(`モード: ${m}`); }
  setMode('edit');

  playBtn.onclick=()=>{ setMode('play'); spawnBall(); };
  stopBtn.onclick=()=>{ setMode('edit'); clearBalls(); };
  editBtn.onclick=()=> setMode('edit');
  setStartBtn.onclick=()=> setMode('setStart');
  setGoalBtn.onclick=()=> setMode('setGoal');
  addBallBtn.onclick=()=> spawnBall();
  clearBallsBtn.onclick=()=> clearBalls();
  clearCourseBtn.onclick=()=> clearCourse();
  lineBtn.onclick=()=>{ currentShape = (currentShape==='line'? null : 'line'); setMode('edit'); };
  eraserBtn.onclick=()=> setMode('eraser');
  freehandBtn.onclick=()=> setMode('freehand');

  function randCol(){return `hsl(${(Math.random()*360)|0} 80% 60%)`;}
  function spawnBall(){const {x,y}=startMarker.position;const ball=Bodies.circle(x,y,12,{restitution:0.3,friction:0.05,frictionAir:0.005,render:{fillStyle:randCol()}});balls.push(ball);World.add(engine.world,ball);}  
  function clearBalls(){balls.splice(0).forEach(b=>World.remove(engine.world,b));}

  const placedWalls=[];
  function addWall(x,y,w,h,angle=0,record=true){const wall=Bodies.rectangle(x,y,w,h,{isStatic:true,angle,render:{fillStyle:'#e6e6e6'}});World.add(engine.world,wall);if(record){placedWalls.push({type:'rect',x,y,w,h,angle});}undoBtn.disabled=placedWalls.length===0;}
  function addCircle(x,y,r,record=true){const c=Bodies.circle(x,y,r,{isStatic:true,render:{fillStyle:'#e6e6e6'}});World.add(engine.world,c);if(record){placedWalls.push({type:'circle',x,y,r});}undoBtn.disabled=placedWalls.length===0;}
  function addTriangle(x,y,s=30,record=true){const t=Bodies.polygon(x,y,3,s,{isStatic:true,render:{fillStyle:'#e6e6e6'}});World.add(engine.world,t);if(record){placedWalls.push({type:'tri',x,y,s});}undoBtn.disabled=placedWalls.length===0;}

  undoBtn.onclick=()=>{ placedWalls.pop(); rebuildCourse(); };
  function clearCourse(){ placedWalls.splice(0); rebuildCourse(); }

  function rebuildCourse(){
    const ballsCopy=[...balls];
    World.clear(engine.world,false);
    World.add(engine.world,[startMarker,goalSensor]);
    placedWalls.forEach(o=>{
      if(o.type==='rect') addWall(o.x,o.y,o.w,o.h,o.angle,false);
      if(o.type==='circle') addCircle(o.x,o.y,o.r,false);
      if(o.type==='tri') addTriangle(o.x,o.y,o.s,false);
    });
    ballsCopy.forEach(b=>World.add(engine.world,b));
    undoBtn.disabled=placedWalls.length===0;
  }

  const palette=document.getElementById('palette');
  palette.querySelectorAll('[draggable=true]').forEach(btn=>{
    btn.addEventListener('dragstart',ev=>{ev.dataTransfer.setData('shape',btn.dataset.shape);});
  });
  worldCanvas.addEventListener('dragover',ev=>ev.preventDefault());
  worldCanvas.addEventListener('drop',ev=>{
    ev.preventDefault();
    const shape=ev.dataTransfer.getData('shape');
    const rect=worldCanvas.getBoundingClientRect();
    const x=ev.clientX-rect.left, y=ev.clientY-rect.top;
    if(shape==='rect') addWall(x,y,40,40);
    if(shape==='circle') addCircle(x,y,20);
    if(shape==='tri') addTriangle(x,y,30);
  });

  let drawingLine=false,sx=0,sy=0,ex=0,ey=0;
  let freehandDrawing=false; let freePts=[];
  let draggingStart=false, draggingGoal=false;
  let currentShape=null;

  function handleDown(x,y){
    if(mode==='edit' && currentShape==='line'){
      drawingLine=true; sx=x; sy=y; ex=x; ey=y;
    } else if(mode==='freehand'){
      freehandDrawing=true; freePts=[{x,y}];
    } else if(mode==='setStart'){
      draggingStart=true;
    } else if(mode==='setGoal'){
      draggingGoal=true;
    } else if(mode==='eraser'){
      for(let i=placedWalls.length-1;i>=0;i--){
        const o=placedWalls[i];
        if(o.type==='rect' && hitRect(o,x,y)){ placedWalls.splice(i,1); break; }
        if(o.type==='circle' && Math.hypot(o.x-x,o.y-y)<=o.r){ placedWalls.splice(i,1); break; }
        if(o.type==='tri' && Math.hypot(o.x-x,o.y-y)<=o.s){ placedWalls.splice(i,1); break; }
      }
      rebuildCourse();
    }
  }
  function handleMove(x,y){
    if(drawingLine){ ex=x; ey=y; }
    if(freehandDrawing){ const last=freePts[freePts.length-1]; if(Math.hypot(x-last.x,y-last.y)>3) freePts.push({x,y}); }
    if(draggingStart){ Body.setPosition(startMarker,{x,y}); }
    if(draggingGoal){ Body.setPosition(goalSensor,{x,y}); }
  }
  function handleUp(){
    if(drawingLine){ drawingLine=false; const len=Math.hypot(ex-sx,ey-sy); if(len>6){ addWall((sx+ex)/2,(sy+ey)/2,len,8,Math.atan2(ey-sy,ex-sx)); }}
    if(freehandDrawing){ freehandDrawing=false; for(let i=1;i<freePts.length;i++){ const p0=freePts[i-1], p1=freePts[i]; const len=Math.hypot(p1.x-p0.x,p1.y-p0.y); if(len>1){ const mx=(p0.x+p1.x)/2, my=(p0.y+p1.y)/2; const ang=Math.atan2(p1.y-p0.y,p1.x-p0.x); addWall(mx,my,len,8,ang); } } freePts=[]; }
    draggingStart=false; draggingGoal=false;
  }

  worldCanvas.addEventListener('mousedown',ev=>{const {x,y}=getMouse(ev);handleDown(x,y);});
  window.addEventListener('mousemove',ev=>{const {x,y}=getMouse(ev);handleMove(x,y);});
  window.addEventListener('mouseup',()=>{handleUp();});

  worldCanvas.addEventListener('touchstart',ev=>{const t=ev.touches[0];const {x,y}=getTouch(t);handleDown(x,y);});
  window.addEventListener('touchmove',ev=>{const t=ev.touches[0];const {x,y}=getTouch(t);handleMove(x,y);});
  window.addEventListener('touchend',()=>{handleUp();});

  function hitRect(o,px,py){ const c=Math.cos(o.angle), s=Math.sin(o.angle); const dx=px-o.x, dy=py-o.y; const lx=dx*c+dy*s; const ly=-dx*s+dy*c; return Math.abs(lx)<=o.w/2 && Math.abs(ly)<=o.h/2; }
  function getMouse(ev){ const r=worldCanvas.getBoundingClientRect(); return {x:ev.clientX-r.left, y:ev.clientY-r.top}; }
  function getTouch(t){ const r=worldCanvas.getBoundingClientRect(); return {x:t.clientX-r.left, y:t.clientY-r.top}; }

  function drawOverlay(){
    octx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    if(drawingLine && mode==='edit' && currentShape==='line'){
      octx.beginPath(); octx.moveTo(sx,sy); octx.lineTo(ex,ey); octx.lineWidth=3; octx.strokeStyle='#55aaff'; octx.stroke();
    }
    if(freehandDrawing && mode==='freehand' && freePts.length){
      octx.beginPath(); octx.moveTo(freePts[0].x,freePts[0].y); for(let i=1;i<freePts.length;i++){ octx.lineTo(freePts[i].x,freePts[i].y); } octx.lineWidth=3; octx.strokeStyle='#ffaa55'; octx.stroke();
    }
    requestAnimationFrame(drawOverlay);
  }
  requestAnimationFrame(drawOverlay);

  saveBtn.onclick=()=>{
    const data={walls:placedWalls,start:startMarker.position,goal:goalSensor.position};
    const blob=new Blob([JSON.stringify(data)],{type:'text/plain'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='course.txt';
    a.click();
  };

  loadBtn.onclick=()=>{
    const input=document.createElement('input');
    input.type='file';
    input.accept='text/plain';
    input.onchange=()=>{
      const file=input.files[0];
      const reader=new FileReader();
      reader.onload=()=>{
        const data=JSON.parse(reader.result);
        placedWalls.splice(0,placedWalls.length,...data.walls);
        Body.setPosition(startMarker,data.start);
        Body.setPosition(goalSensor,data.goal);
        rebuildCourse();
      };
      reader.readAsText(file);
    };
    input.click();
  };

  function flash(t){ msg.textContent=t; clearTimeout(flash._t); flash._t=setTimeout(()=>msg.textContent='',2500); }

  window.addEventListener('contextmenu',e=>e.preventDefault());
})();
</script>
</body>
</html>
